//
//  AuditionObject.swift
//  audition
//
//  Created by Jake Medina on 1/15/25.
//

import Foundation
import CryptoKit
import PencilKit

protocol SHA256Hashable {
    var sha256DigestObject: SHA256Digest? { get }
    var sha256DigestValue: String? { get }
}

protocol Plistable {
    var plist: Data { get throws }
}

protocol AuditionObjectProtocol: SHA256Hashable, CustomStringConvertible, Codable, Plistable {
    var type: AuditionObjectType { get }
}

extension AuditionObjectProtocol {
    var plist: Data {
        get throws {
            let encoder = PropertyListEncoder()
            encoder.outputFormat = .binary
            let plistData = try encoder.encode(self)
            return plistData
        }
    }
    
    // create a hash using all of the contents of a commit: type, tree, parents, message, and timestamp
    // NOTE: the hash is generated by using a PropertyListEncoder to create a binary PropertyList representation of this object.
    // currently, I don't know how to reproduce this hash without the use of PropertyListEncoder due to my knowledge gaps on the exact steps it takes to encode the data into a plist.
    // it seems that there is a deterministic ordering of the plist that is done by PropertyListEncoder
    // if, in the future, we want to easily switch to a more reproducible hash, the easiest way would be to change the PropertyListEncoder's outputFormat to .xml
    // then, the hash can be reproduced by creating a dictionary with all of the properties of this object and passing it to PropertyListSerialization.data(fromPropertyList: *the dictionary*, format: .xml)
    var sha256DigestObject: SHA256Digest? {
        do {
            return SHA256.hash(data: try plist)
        } catch {
            print("Unable to serialize \(self.type.rawValue.capitalized) to plist:\n\(self.description)")
            return nil
        }
    }
    
    var sha256DigestValue: String? {
        return sha256DigestObject?.hexString
    }
}

enum AuditionObjectType: String, Equatable, Codable {
    case blob = "blob"
    case tree = "tree"
    case commit = "commit"
}

class Blob: AuditionObjectProtocol, Equatable {
    let type: AuditionObjectType
    let contents: Data
    let contentTypeIdentifier: String?
    
    init(contents: Data, contentTypeIdentifier: String? = nil) {
        type = AuditionObjectType.blob
        self.contents = contents
        self.contentTypeIdentifier = contentTypeIdentifier
    }
    
    init(from file: AuditionFile) {
        type = AuditionObjectType.blob
        self.contents = file.content
        self.contentTypeIdentifier = file.contentTypeIdentifier
    }
    
    var isDrawing: Bool {
        return contentTypeIdentifier == (PKAppleDrawingTypeIdentifier as String)
    }
    
    // TODO: In the future, blobs will primarily contain PKStroke data. We need to make a type identifier for PKStroke data.
    #warning("In the future, blobs will primarily contain PKStroke data. We need to make a type identifier for PKStroke data.)")
    func createDrawing() throws -> PKDrawing {
        guard isDrawing else {
            throw AuditionError.runtimeError("Cannot create drawing from Blob. Blob contentTypeIdentifier does not indicate that this blob contains a PKDrawing.")
        }
        return try PKDrawing(data: contents)
    }
    
    static func == (lhs: Blob, rhs: Blob) -> Bool {
        return lhs.type == rhs.type && lhs.contents == rhs.contents && lhs.contentTypeIdentifier == rhs.contentTypeIdentifier
    }
    
    public var description: String {
        return contents.description
    }
}

// TODO: implement Comparable
// stores information about either trees or blobs
struct TreeEntry: CustomStringConvertible, Plistable, Equatable, Comparable, Codable {
    let type: AuditionObjectType
    var hash: String
    let name: String
    
    var plist: Data {
        get throws {
            let encoder = PropertyListEncoder()
            encoder.outputFormat = .binary
            let plistData = try encoder.encode(self)
            return plistData
        }
    }
    
    static func < (lhs: TreeEntry, rhs: TreeEntry) -> Bool {
        return lhs.name.compare(rhs.name, options: .caseInsensitive) == .orderedAscending
    }
    
    public var description: String {
        return "\(type) \(hash)      \(name)"
    }
}

class Tree: AuditionObjectProtocol, Equatable {
    let type: AuditionObjectType
    
    // Tree entries MUST be sorted alphabetically by their name
    let entries: [TreeEntry]
    
    init(entries: [TreeEntry]) {
        type = AuditionObjectType.tree
        self.entries = entries.sorted()
    }
    
    static func == (lhs: Tree, rhs: Tree) -> Bool {
        // we don't have to sort since the entries are already sorted upon initialization
        return lhs.type == rhs.type && lhs.entries == rhs.entries
    }
    
    public var description: String {
        var entriesStr: [String] = []
        for item in entries {
            entriesStr.append(item.description)
        }
        return entriesStr.joined(separator: "\n")
    }
}

class Commit: AuditionObjectProtocol, Equatable, ObservableObject {
    let type: AuditionObjectType
    let tree: String
    let parents: [String]
    let message: String
    let timestamp: Date
    
    init(tree: String, parents: [String], message: String, timestamp: Date) {
        self.type = AuditionObjectType.commit
        self.tree = tree
        self.parents = parents
        self.message = message
        self.timestamp = timestamp
    }
    
    static func == (lhs: Commit, rhs: Commit) -> Bool {
        return lhs.type == rhs.type && lhs.tree == rhs.tree && lhs.parents == rhs.parents && lhs.message == rhs.message && lhs.timestamp == rhs.timestamp
    }
    
    public var description: String {
        let treeDescription: String = "tree \(tree)"
        
        let parentsDescription: String = {
            var parentsAppend = parents
            for (idx, item) in parentsAppend.enumerated() {
                parentsAppend[idx] = "parent \(item)"
            }
            return parentsAppend.joined(separator: "\n")
        }()
        
        return "\(treeDescription)\n\(parentsDescription)\n\(timestamp)\n\n\(message)"
    }
}

extension SHA256Digest{
    public var hexString: String {
        let input = Data(self) as NSData
        var bytes = [UInt8](repeating: 0, count: input.length)
        input.getBytes(&bytes, length: input.length)
        
        var hexString = ""
        for byte in bytes {
            hexString += String(format:"%02x", UInt8(byte))
        }
        return hexString
    }
}
